#include "../include/transaction.h"
#include "../include/utils.h"
#include <sstream>
#include <stdexcept>
#include <iostream>
#include <algorithm>

// Constructor for coin transfer
Transaction::Transaction(const std::string& fromAddress, const std::string& toAddress, double amount)
    : m_fromAddress(fromAddress),
      m_toAddress(toAddress),
      m_amount(amount),
      m_timestamp(std::time(nullptr)),
      m_type(TransactionType::COIN_TRANSFER),
      m_memoryProofHash("") {
    // Validation
    if (fromAddress == toAddress) {
        throw std::invalid_argument("Sender and recipient cannot be the same");
    }
    
    if (amount <= 0) {
        throw std::invalid_argument("Amount must be positive");
    }
}

// Constructor for memory reward
Transaction::Transaction(const std::string& toAddress, double amount, const std::string& memoryProofHash)
    : m_fromAddress(""),
      m_toAddress(toAddress),
      m_amount(amount),
      m_timestamp(std::time(nullptr)),
      m_type(TransactionType::MEMORY_REWARD),
      m_memoryProofHash(memoryProofHash) {
    // Validation
    if (toAddress.empty()) {
        throw std::invalid_argument("Recipient address cannot be empty");
    }
    
    if (amount <= 0) {
        throw std::invalid_argument("Reward amount must be positive");
    }
    
    if (memoryProofHash.empty() && !memoryProofHash.empty()) { // Allow empty hash for mining rewards
        throw std::invalid_argument("Memory proof hash cannot be empty for memory rewards");
    }
}

void Transaction::signTransaction(const std::string& privateKey) {
    // Only if this is a coin transfer (memory rewards don't need signing)
    if (m_type == TransactionType::COIN_TRANSFER) {
        if (m_fromAddress.empty()) {
            throw std::invalid_argument("Cannot sign transaction without a sender address");
        }
        
        // Calculate the hash and sign it with the private key
        std::string txHash = calculateHash();
        m_signature = ahmiyat::utils::sign(privateKey, txHash);
    }
}

bool Transaction::isValid() const {
    // Memory rewards don't need validation (they're generated by the system)
    if (m_type == TransactionType::MEMORY_REWARD) {
        return true;
    }
    
    // For coin transfers, verify the signature
    if (m_fromAddress.empty()) {
        throw std::invalid_argument("Cannot validate transaction without a sender address");
    }
    
    if (m_signature.empty()) {
        throw std::invalid_argument("Cannot validate unsigned transaction");
    }
    
    return ahmiyat::utils::verify(m_fromAddress, m_signature, calculateHash());
}

std::string Transaction::calculateHash() const {
    std::stringstream ss;
    ss << m_fromAddress << m_toAddress << m_amount << m_timestamp;
    
    if (m_type == TransactionType::MEMORY_REWARD) {
        ss << "MEMORY_REWARD" << m_memoryProofHash;
    } else {
        ss << "COIN_TRANSFER";
    }
    
    return ahmiyat::utils::sha256(ss.str());
}

std::string Transaction::getFromAddress() const {
    return m_fromAddress;
}

std::string Transaction::getToAddress() const {
    return m_toAddress;
}

double Transaction::getAmount() const {
    return m_amount;
}

time_t Transaction::getTimestamp() const {
    return m_timestamp;
}

std::string Transaction::getSignature() const {
    return m_signature;
}

Transaction::TransactionType Transaction::getType() const {
    return m_type;
}

std::string Transaction::getMemoryProofHash() const {
    return m_memoryProofHash;
}

std::string Transaction::toJson() const {
    std::stringstream ss;
    ss << "{";
    ss << "\"fromAddress\":\"" << ahmiyat::utils::jsonEscape(m_fromAddress) << "\",";
    ss << "\"toAddress\":\"" << ahmiyat::utils::jsonEscape(m_toAddress) << "\",";
    ss << "\"amount\":" << ahmiyat::utils::doubleToString(m_amount) << ",";
    ss << "\"timestamp\":" << m_timestamp << ",";
    ss << "\"signature\":\"" << ahmiyat::utils::jsonEscape(m_signature) << "\",";
    ss << "\"type\":\"" << (m_type == TransactionType::COIN_TRANSFER ? "COIN_TRANSFER" : "MEMORY_REWARD") << "\",";
    ss << "\"memoryProofHash\":\"" << ahmiyat::utils::jsonEscape(m_memoryProofHash) << "\"";
    ss << "}";
    
    return ss.str();
}

Transaction Transaction::fromJson(const std::string& json) {
    try {
        // Create an empty transaction
        Transaction tx;
        
        // Find key-value pairs
        auto extractValue = [&json](const std::string& key) -> std::string {
            size_t keyPos = json.find("\"" + key + "\"");
            if (keyPos == std::string::npos) return "";
            
            size_t colonPos = json.find(":", keyPos);
            if (colonPos == std::string::npos) return "";
            
            size_t valueStart = json.find_first_not_of(" \t\n\r", colonPos + 1);
            if (valueStart == std::string::npos) return "";
            
            if (json[valueStart] == '\"') {
                // String value
                valueStart++; // Skip the opening quote
                size_t valueEnd = json.find("\"", valueStart);
                if (valueEnd == std::string::npos) return "";
                return json.substr(valueStart, valueEnd - valueStart);
            } else {
                // Numeric value
                size_t valueEnd = json.find_first_of(",}\n", valueStart);
                if (valueEnd == std::string::npos) return "";
                return json.substr(valueStart, valueEnd - valueStart);
            }
        };
        
        // Extract values
        tx.m_fromAddress = extractValue("fromAddress");
        tx.m_toAddress = extractValue("toAddress");
        std::string amountStr = extractValue("amount");
        std::string timestampStr = extractValue("timestamp");
        tx.m_signature = extractValue("signature");
        std::string typeStr = extractValue("type");
        tx.m_memoryProofHash = extractValue("memoryProofHash");
        
        // Convert to appropriate types
        tx.m_amount = ahmiyat::utils::stringToDouble(amountStr);
        tx.m_timestamp = ahmiyat::utils::stringToTime(timestampStr);
        tx.m_type = (typeStr == "COIN_TRANSFER") ? 
                    TransactionType::COIN_TRANSFER : TransactionType::MEMORY_REWARD;
        
        return tx;
    } catch (const std::exception& e) {
        std::cerr << "Error parsing transaction JSON: " << e.what() << std::endl;
        
        // Return a dummy transaction in case of error
        Transaction dummy;
        dummy.m_toAddress = "ERROR";
        return dummy;
    }
}
